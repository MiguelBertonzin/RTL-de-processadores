library IEEE; use IEEE.std_logic_1164.all; 
 
entity fsm_laser is 
port (  i_CLR_n    : in std_logic; -- clear/reset         i_CLK      : in std_logic; -- data input         i_B        : in std_logic; 
        i_S        : in std_logic; 
    o_L        : out std_logic;         o_Dreg_clr : out std_logic;         o_Dreg_ld  : out std_logic;         o_Dctr_clr : out std_logic; 
        o_Dctr_ld  : out std_logic); 
end fsm_laser; 
 
architecture arch_1 of fsm_laser is 
type t_STATE is (s_0, s_1, s_2, s_3, s_4); --declaração de estados signal r_STATE : t_STATE; -- registrados de estados 
signal w_NEXT : t_STATE; -- cabo para passagem do próximo estado begin 
---- processo de registro ---- p_STATE: process(i_CLR_n, i_CLK) begin 
if (i_CLR_n <= '0') then --caso reinício, estado 00     r_STATE <= s_0; 
elsif (rising_edge(i_CLK)) then --a cada pulso do clock atualiza o estado     r_STATE <= w_NEXT; 
end if; 
end process; 
 
---- processo para próximo estado ---- p_NEXT: process(r_STATE, i_S, i_B) begin 
case (r_STATE) is 
when s_0 => w_NEXT <= s_1;  when s_1 => 
    if(i_B = '1') then       w_NEXT <= s_2; 
 	  else   	    w_NEXT <= s_1; 
    end if;     
when s_2 => w_NEXT <= s_3;  when s_3 => 
    if(i_S = '1') then       w_NEXT <= s_4; 
 	  else   	    w_NEXT <= s_3; 
    end if; 
when s_4 => w_NEXT <= s_1; when others => w_NEXT <= s_0;  
end case; end process; 
 
---- saídas em relação ao registrador de estados o_L <= '1' when (r_STATE = s_2) else '0'; o_Dreg_clr <= '1' when (r_STATE = s_0) else '0'; o_Dreg_ld <= '1' when (r_STATE = s_4) else '0'; o_Dctr_clr <= '1' when(r_STATE = s_1) else '0'; o_Dctr_ld <= '1' when(r_STATE = s_3) else '0'; end arch_1; 
